\documentclass[11pt]{article}
\usepackage[T1]{fontenc}
\usepackage{listings}
\usepackage{hyperref}
\usepackage{color}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=c++,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}
%Template of a bullet list
% \begin{itemize}
%  \item{
%              thie
%
%        }
%\end{itemize}


\setlength{\parindent}{0pt}
\setlength{\parskip}{0pt plus 0.5ex}
%% adjust spacing for all itemize/enumerate

\begin{document}
%TODO: add this in later once everything is complete
%\tableofcontents
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%Arrays and Hashmaps%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Array and Hashmaps}
Arrays and hashmaps are datastructures used to store a collection of variables.
We can access elements in an array by providing an integer based index. On the other hand, we can access elements of a hashmap by providing a unique key which corresponds to an element. The key could be any variable/object.
\subsection{
 \href{https://leetcode.com/problems/group-anagrams/submissions/}{Group Anagrams}
}
The key  idea to solve this question would be that the template of a map could be yet another map.

\begin {lstlisting}
map<map<char,int>,vector<string>> ans;
\end{lstlisting}
\begin{enumerate}
 \item {
       
       For each element in the given string, we would generate a
       \begin {lstlisting}
       map<char,int> obj
       \end{lstlisting}
       where obj would keep count of the number of characters that have appeared in the given string.
       }
       
       \item{
                   Obj would be used as a key to insert the current string in the correct index of the ans map.
             }
 \item {
       Lastly, we would just have to transfer the nested vectors in the ans map to the correct type.
       In this case, it is vector<vector<string>>.
       }
\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%Two Pointers%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Two Pointers}
The main idea to two pointers would be to pick a pair of elements from an array, where the chosen pair of elements would satisfy some condition. More often than not, we would sort the array first.

A common application would be to find a pair of integers whose sum is = to some value.
\begin{enumerate}
 \item{Sort the array of integers}
 \item{
       
             We would initialize the left integer iterator to be 0 to refer to the left most index, and the right integer iterator to be the size of the array to refer to the right most index.
       }
 \item{
             If the current sum is too low, we would increase the left iterator to achieve a greater sum.
       }
 \item{
             If the current sum is too high, we would decrease the right iterator to achieve a lower sum.
       }
 \item {
       If the left iterator = right iterator, then we have not found a pair of integers to satisfy the given sum.
       }
\end{enumerate}



\subsection{
 \href{https://leetcode.com/problems/valid-palindrome/submissions/}{Valid Palindrome}
}
The hardest part to this question would be to convert a arbitary string to an array of
alphanumeric characters only. Then, we could apply the two pointers idea to compare the first and the last elements in the array, to see if they match.
\begin{lstlisting}
vector<char> filtered;
for(int i=0;i<s.length();i++){
  if(isalnum(s[i])){
    filtered.push_back(tolower(s[i]));
   }
 }
\end{lstlisting}

\subsection{
 \href{https://leetcode.com/problems/3sum/}{3Sum}
}

This problem could be reduced to the \href{https://leetcode.com/problems/two-sum/}{2Sum}
problem, albeit with a couple of modifications.
\begin{enumerate}
 \item{
             If the given array has less than 3 elements, we can't really do anything. Thus, we should just return an empty array.
             
       }
 \item{
             We would sort the given array at first.
       }
 \item{
             Then, we would pick the first element (starting from the left of the array).
             Starting from index 1 and above, we should check the element to the left to see if we have already checked it. This step is critical to ensure that we do not create duplicate triplets.
       }
 \item {
       Then, we would use the two pointers idea to find a pair of elements which would satisfy the criteria of $ele1+ele2+ele3=0$. Once we have found a suitable pair, we should continue checking, as there could be more than one solution.
       
       }
       \item{
                   We could use a set to ensure that we do not generate identical triplets, before copying the contents of the set back to a vector of vector<int>.
             }
\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%Sliding window %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Sliding Window}
The sliding window method is somewhat similar to the two pointers method in terms of having two iterators which move about in an array. The key conceptual difference would be that in the sliding window method, we are more interested in the properties of elements between the two pointers, as supposed to just the elements at the two pointers.

For example, we could be interested in a continuous subset of elements, which do not contain duplicates. Thus, the elements between(and at) the two pointers must not be equal to one another. 

\end{document}
